use std::env;
use std::fs;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};
use csv::Reader;

extern crate csv;

pub fn generate_array(
    // The input file path
    input_path: &str,
    // The output file path
    output_path: &str,
    // If true, use spaces as the delimiter, otherwise use commas
    use_spaces: bool,
) -> Result<(), Box<dyn std::error::Error>> {
    // Open the input file
    let input_file = File::open(input_path)?;
    // Create a buffered reader for the input file
    let reader = BufReader::new(input_file);
    // Open the output file
    let output_file = File::create(output_path)?;

    // Write the top comments
    writeln!(
        &output_file,
        "/* Objects the Player can buy */\n\n/* Radius prevents hostiles walking through objects */\n\n/*  Price - Display Name - Class Name - Rotation When Bought - Object Radius (meters) - explosive - invincible -  Has AI true/false (for objects with AI like autonomous turrests)  */\n"
    )?;

    // Write the opening of the array
    writeln!(&output_file, "BUILDER_ITEMS = [")?;

    let mut is_first_line = true;

    // Use CSV reader if input is a CSV file, otherwise use the existing code
    if input_path.ends_with(".csv") {
        let mut csv_reader = Reader::from_reader(reader);
        for result in csv_reader.records() {
            let record = result?;
            let parts: Vec<&str> = record.iter().map(|s| s.trim()).collect();
            if parts.len() < 8 {
                return Err("Line is not properly formatted.".into());
            }

            let cost = parts[0];
            let item_name = parts[1];
            let classname = parts[2];
            let rotation = parts[3];
            let radius = parts[4];
            let explosive = parts[5];
            let invincible = parts[6];
            let has_ai = parts[7];

            if !is_first_line {
                writeln!(&output_file, ",")?;
            } else {
                is_first_line = false;
            }
            write!(
                &output_file,
                "\t[{}, \"{}\", \"{}\", {}, {}, {}, {}, {}]",
                cost, item_name, classname, rotation, radius, explosive, invincible, has_ai
            )?;
        }
    } else {
        for (i, line) in reader.lines().enumerate() {
            let line = line?;
            let parts: Vec<&str> = if use_spaces {
                line.split_whitespace().collect()
            } else {
                line.split(",").map(|s| s.trim()).collect()
            };

            if parts.len() < 8 {
                return Err(format!("Line {} is not properly formatted.", i + 1).into());
            }

            let cost = parts[0];
            let item_name = parts[1];
            let classname = parts[2];
            let rotation = parts[3];
            let radius = parts[4];
            let explosive = parts[5];
            let invincible = parts[6];
            let has_ai = parts[7];

            if !is_first_line {
                writeln!(&output_file, ",")?;
            } else {
                is_first_line = false;
            }
            write!(
                &output_file,
                "\t[{}, \"{}\", \"{}\", {}, {}, {}, {}, {}]",
                cost, item_name, classname, rotation, radius, explosive, invincible, has_ai
            )?;
        }
    }

    // Write the closing of the array
    writeln!(&output_file, "\n];")?;
    writeln!(&output_file, "\n// Generated by ArrayGen v1.0.5")?;

    Ok(())
}

pub fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Get the arguments
    let args: Vec<String> = env::args().collect();
    // Get the input path
    let input_path = if args.contains(&"-csv".to_string()) {
        "input.csv"
    } else {
        "input.txt"
    };

    // Get the output path
    let output_path = "editMe.sqf";
    // Determine if we should use spaces or tabs for formatting
    let use_spaces = args.contains(&"-spaces".to_string());
    // Remove the output file if it already exists
    if let Err(e) = fs::remove_file(output_path) {
        if e.kind() != std::io::ErrorKind::NotFound {
            return Err(e.into());
        }
    }

    // Generate the array from the input file
    generate_array(input_path, output_path, use_spaces)?;

    Ok(())
}

